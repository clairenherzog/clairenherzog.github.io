```javascript
/**
 * kandinskyDreams.js
 *
 * p5.js sketch: an animated abstract painting inspired by the colorful geometric spirit
 * of Wassily Kandinsky. Drop this file into an environment with p5.js (online editor or local).
 *
 * Features:
 * - Layered geometric shapes (circles, arcs, rectangles, lines, polygons)
 * - Bold, vibrant palette with high contrast
 * - Subtle motion: rotation, drifting, pulsing, and noise-driven wiggle
 * - Composition rules that mimic a "constructed" abstract painting
 * - Responsive to window size and simple mouse interaction (moves focal gravity)
 *
 * Usage:
 * Include p5.js and this script:
 * <script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/p5.min.js"></script>
 * <script src="kandinskyDreams.js"></script>
 */

let palette;
let shapes = [];
let bgTexture;
let t = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 1);
  noStroke();
  rectMode(CENTER);
  angleMode(RADIANS);
  pixelDensity(1);

  // A Kandinsky-esque palette (vibrant primaries + muted neutrals)
  palette = {
    deepBlue: color(220, 85, 55),
    vividYellow: color(50, 95, 95),
    warmRed: color(12, 85, 90),
    teal: color(185, 80, 68),
    lavender: color(265, 60, 86),
    black: color(0, 0, 8),
    offWhite: color(40, 12, 98),
    paleGray: color(210, 8, 92)
  };

  // Create background texture for painterly feel
  bgTexture = createGraphics(width, height);
  generateBgTexture();

  // Seed random shapes compositionally: a "constructed" layout with focal points
  initShapes();
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  bgTexture = createGraphics(width, height);
  generateBgTexture();
  shapes = [];
  initShapes();
}

function draw() {
  t += deltaTime * 0.0015;

  // base background
  background(palette.offWhite);

  // paint the textured background
  push();
  blendMode(MULTIPLY);
  image(bgTexture, 0, 0, width, height);
  pop();

  // slight vignette
  drawVignette();

  // update & render shapes in layered order
  // layers: background forms, focal shapes, accent lines, small details
  for (let s of shapes) s.update(t);
  shapes.sort((a, b) => a.z - b.z); // painter's z-order
  for (let s of shapes) s.draw();

  // overlay: dynamic linear "staff" elements typical in Kandinsky
  drawFloatingLines();

  // grain for tactile paper feel
  drawGrain();
}

/* ---------- Composition & Shapes ---------- */

function initShapes() {
  const cx = width * 0.45;
  const cy = height * 0.45;
  const minDim = min(width, height);

  // large off-center circle (focal)
  shapes.push(new GShape({
    type: "circle",
    x: cx + minDim * 0.06,
    y: cy - minDim * 0.08,
    w: minDim * 0.45,
    h: minDim * 0.45,
    fill: palette.deepBlue,
    stroke: palette.black,
    z: 1,
    rotation: random(-0.3, 0.3),
    motion: { rotateSpeed: 0.02, pulse: 0.12, drift: 0.01 }
  }));

  // secondary yellow circle - overlapping, smaller
  shapes.push(new GShape({
    type: "circle",
    x: cx + minDim * 0.22,
    y: cy + minDim * 0.18,
    w: minDim * 0.18,
    h: minDim * 0.18,
    fill: palette.vividYellow,
    stroke: palette.black,
    z: 2,
    rotation: 0,
    motion: { rotateSpeed: -0.04, pulse: 0.2, drift: 0.03 }
  }));

  // tilted rectangle / plane
  shapes.push(new GShape({
    type: "rect",
    x: cx - minDim * 0.22,
    y: cy + minDim * 0.06,
    w: minDim * 0.38,
    h: minDim * 0.16,
    fill: palette.lavender,
    stroke: palette.black,
    z: 0.5,
    rotation: -0.6,
    motion: { rotateSpeed: 0.01, pulse: 0.06, drift: 0.008 }
  }));

  // cluster of small discs and triangles (details)
  let detailCount = 18;
  for (let i = 0; i < detailCount; i++) {
    const ang = random(TWO_PI);
    const r = random(minDim * 0.06, minDim * 0.35);
    shapes.push(new GShape({
      type: random(["circle", "triangle", "polygon"]),
      x: cx + cos(ang) * r + random(-20, 20),
      y: cy + sin(ang) * r + random(-20, 20),
      w: random(minDim * 0.02, minDim * 0.07),
      h: random(minDim * 0.02, minDim * 0.07),
      fill: random([palette.warmRed, palette.teal, palette.vividYellow]),
      stroke: palette.black,
      z: map(i, 0, detailCount, 3, 6),
      rotation: random(-PI, PI),
      motion: { rotateSpeed: random(-0.12, 0.12), pulse: random(0.06, 0.25), drift: random(0.02, 0.06) }
    }));
  }

  // arcs and rings for rhythmic geometry
  for (let i = 0; i < 4; i++) {
    shapes.push(new GShape({
      type: "arc",
      x: cx + random(-minDim * 0.15, minDim * 0.15),
      y: cy + random(-minDim * 0.15, minDim * 0.15),
      w: minDim * random(0.14, 0.5),
      h: minDim * random(0.14, 0.5),
      fill: null,
      stroke: random([palette.deepBlue, palette.black, palette.teal]),
      z: -0.5 + i * 0.4,
      rotation: random(-1.2, 1.2),
      motion: { rotateSpeed: random(-0.02, 0.02), pulse: 0.0, drift: 0.01 }
    }));
  }

  // heavy black form (anchor)
  shapes.push(new GShape({
    type: "blob",
    x: cx - minDim * 0.35,
    y: cy - minDim * 0.25,
    w: minDim * 0.18,
    h: minDim * 0.26,
    fill: palette.black,
    stroke: null,
    z: 4,
    rotation: 0,
    motion: { rotateSpeed: 0.0, pulse: 0.02, drift: 0.01 }
  }));
}

/* ---------- GShape class ---------- */

class GShape {
  constructor(opts = {}) {
    this.type = opts.type || "circle";
    this.x = opts.x || width / 2;
    this.y = opts.y || height / 2;
    this.baseX = this.x;
    this.baseY = this.y;
    this.w = opts.w || 100;
    this.h = opts.h || (opts.w || 100);
    this.fill = opts.fill || palette.vividYellow;
    this.stroke = opts.stroke || null;
    this.z = opts.z || 0;
    this.rotation = opts.rotation || 0;
    this.baseRotation = this.rotation;
    this.motion = Object.assign({ rotateSpeed: 0, pulse: 0, drift: 0 }, opts.motion || {});
    this.noiseSeed = random(1000);
    this.polygonSides = floor(random(3, 7));
  }

  update(time) {
    // drifting position influenced by Perlin noise + mouse proximity
    const driftScale = (min(width, height) / 1200) * this.motion.drift;
    const nx = noise(this.noiseSeed + time * 0.18);
    const ny = noise(this.noiseSeed + 10 + time * 0.18);
    const mx = map(nx, 0, 1, -1, 1) * 30 * driftScale;
    const my = map(ny, 0, 1, -1, 1) * 30 * driftScale;

    // focal gravity towards mouse for subtle interactivity
    const mouseInfluence = 0.002;
    const dx = mouseX - this.baseX;
    const dy = mouseY - this.baseY;
    const distToMouse = sqrt(dx * dx + dy * dy);
    const f = constrain(map(distToMouse, 0, max(width, height), 0.9, 0.02), 0, 1);

    this.x = this.baseX + mx + (mouseX - width / 2) * mouseInfluence * f;
    this.y = this.baseY + my + (mouseY - height / 2) * mouseInfluence * f;

    // rotation + pulsing size
    this.rotation = this.baseRotation + time * this.motion.rotateSpeed + 0.2 * (noise(this.noiseSeed + 50 + time * 0.3) - 0.5);
    const pulse = 1 + sin(time * (0.5 + this.motion.rotateSpeed * 2) + this.noiseSeed) * this.motion.pulse;
    this.curW = this.w * pulse;
    this.curH = this.h * pulse;
  }

  draw() {
    push();
    translate(this.x, this.y);
    rotate(this.rotation);

    // fill
    if (this.fill) {
      fill(this.fill);
    } else {
      noFill();
    }
    if (this.stroke) {
      strokeWeight(max(1, map(this.z, -2, 6, 1, 6)));
      stroke(this.stroke);
    } else {
      noStroke();
    }

    // subtle painterly edge: draw multiple translucent outlines for certain shapes
    const edgePasses = (this.type === "circle" || this.type === "rect") ? 2 : 1;
    for (let p = edgePasses - 1; p >= 0; p--) {
      const alpha = 0.9 - p * 0.35;
      if (this.fill) {
        fill(
          hue(this.fill),
          saturation(this.fill),
          brightness(this.fill),
          alpha
        );
      } else {
        noFill();
      }

      switch (this.type) {
        case "circle":
          ellipse(0, 0, this.curW * (1 + p * 0.02), this.curH * (1 + p * 0.02));
          break;
        case "rect":
          push();
          rotate(0.05 * p);
          rect(0, 0, this.curW * (1 + p * 0.02), this.curH * (1 + p * 0.02));
          pop();
          break;
        case "triangle":
          this._drawTriangle(this.curW, this.curH);
          break;
        case "polygon":
          this._drawPolygon(this.curW * 0.6, this.polygonSides);
          break;
        case "arc":
          this._drawArc(this.curW, this.curH, p);
          break;
        case "blob":
          this._drawBlob(this.curW, this.curH, p);
          break;
        default:
          ellipse(0, 0, this.curW, this.curH);
      }
    }

    // if stroke present, draw thin crisp stroke on top
    if (this.stroke) {
      noFill();
      stroke(this.stroke);
      strokeWeight(1.6);
      switch (this.type) {
        case "circle":
          ellipse(0, 0, this.curW, this.curH);
          break;
        case "rect":
          rect(0, 0, this.curW, this.curH);
          break;
        case "triangle":
          this._drawTriangle(this.curW, this.curH, false);
          break;
        case "polygon":
          this._drawPolygon(this.curW * 0.6, this.polygonSides, false);
          break;
        case "arc":
          this._drawArc(this.curW, this.curH, 0, false);
          break;
        case "blob":
          this._drawBlob(this.curW, this.curH, 0, false);
          break;
        default:
          ellipse(0, 0, this.curW, this.curH);
      }
    }

    pop();
  }

  _drawTriangle(w, h, filled = true) {
    if (filled) beginShape();
    const verts = [
      { x: 0, y: -h * 0.58 },
      { x: -w * 0.5, y: h * 0.45 },
      { x: w * 0.5, y: h * 0.45 }
    ];
    if (filled) {
      vertex(verts[0].x, verts[0].y);
      vertex(verts[1].x, verts[1].y);
      vertex(verts[2].x, verts[2].y);
      endShape(CLOSE);
    } else {
      triangle(verts[0].x, verts[0].y, verts[1].x, verts[1].y, verts[2].x, verts[2].y);
    }
  }

  _drawPolygon(radius, sides, filled = true) {
    if (filled) beginShape();
    for (let i = 0; i < sides; i++) {
      const a = map(i, 0, sides, 0, TWO_PI) - PI / 2;
      const vx = cos(a) * radius;
      const vy = sin(a) * radius;
      if (filled) vertex(vx, vy);
      else line(vx, vy, cos(a + 0.02) * radius, sin(a + 0.02) * radius);
    }
    if (filled) endShape(CLOSE);
  }

  _drawArc(w, h, pass = 0, filled = true) {
    const start = -PI / 2 + pass * 0.15;
    const end = PI / 2 + pass * 0.15 + sin(t + this.noiseSeed) * 0.4;
    strokeCap(SQUARE);
    noFill();
    strokeWeight(2.0 + pass);
    arc(0, 0, w, h, start, end);
  }

  _drawBlob(w, h, pass = 0, filled = true) {
    // organic rounded polygon using noise
    beginShape();
    for (let i = 0; i < 20; i++) {
      const a = map(i, 0, 20, 0, TWO_PI);
      const n = noise(this.noiseSeed + cos(a) * 0.5 + sin(a) * 0.3 + t * 0.2);
      const r = (w * 0.5) * (0.5 + n * 0.9) * (1 + pass * 0.03);
      vertex(cos(a) * r, sin(a) * r * (h / w));
    }
    endShape(CLOSE);
  }
}

/* ---------- Accent lines and rhythms ---------- */

function drawFloatingLines() {
  push();
  translate(width * 0.05, height * 0.05);
  strokeWeight(3);
  stroke(palette.black);
  const lines = 6;
  for (let i = 0; i < lines; i++) {
    const y = map(i, 0, lines - 1, height * 0.08, height * 0.92);
    const wobble = sin(t * (0.6 + i * 0.12) + i) * 40;
    // broken staff-like line with small discs at intersections
    drawingContext.setLineDash([10, 8]);
    line(0, y, width * 0.9 + wobble, y + sin(i * 0.8 + t) * 18);
    drawingContext.setLineDash([]);
    // small accent circles along line
    for (let j = 0; j < 4; j++) {
      const px = map(j, 0, 3, 0, width * 0.9) + sin(t * 0.4 + j) * 8;
      fill(j % 2 ? palette.vividYellow : palette.warmRed);
      noStroke();
      ellipse(px, y + sin(t * 0.7 + j) * 6, 12 + j * 3, 12 + j * 3);
    }
  }
  pop();
}

/* ---------- Background & Texture helpers ---------- */

function generateBgTexture() {
  bgTexture.clear();
  bgTexture.noStroke();
  bgTexture.colorMode(HSB, 360, 100, 100, 1);
  // base soft wash
  for (let i = 0; i < 60; i++) {
    const x = random(width);
    const y = random(height);
    const s = random(0.03, 0.12) * max(width, height);
    bgTexture.fill(220, 6, 95, 0.03);
    bgTexture.ellipse(x, y, s, s * random(0.6, 1.6));
  }
  // subtle watercolor blotches
  for (let i = 0; i < 30; i++) {
    bgTexture.fill(40, 8, 96, 0.05);
    bgTexture.ellipse(random(width), random(height), random(60, 240), random(40, 160));
  }
  // light paper grain via transparent dots
  bgTexture.fill(0, 0, 0, 0.015);
  for (let i = 0; i < width * height * 0.00012; i++) {
    bgTexture.ellipse(random(width), random(height), 1, 1);
  }
}

function drawVignette() {
  push();
  noFill();
  for (let i = 0; i < 40; i++) {
    const a = map(i, 0, 39, 0, 100);
    stroke(0, 0, 10, map(i, 0, 39, 0.0, 0.28));
    strokeWeight( (i/6)+0.2 );
    rect(width / 2, height / 2, width * (1 - i * 0.02), height * (1 - i * 0.02));
  }
  pop();
}

function drawGrain() {
  push();
  blendMode(OVERLAY);
  for (let i = 0; i < 1200; i++) {
    const x = random(width);
    const y = random(height);
    const a = random(0.02, 0.08);
    fill(0, 0, 100, a);
    noStroke();
    rect(x, y, 1, 1);
  }
  pop();
}

/* ---------- Utility ---------- */

// Simple helpers to query HSB channels of a p5.Color (since p5 lacks getters)
function hue(c) {
  return Math.round(_getColorComponent(c, 'h'));
}
function saturation(c) {
  return Math.round(_getColorComponent(c, 's'));
}
function brightness(c) {
  return Math.round(_getColorComponent(c, 'b'));
}
function _getColorComponent(c, which) {
  // convert to HSB by drawing to a small graphics buffer and reading pixels
  // Lightweight approach: use HSB conversion math approximated via p5's colorMode shift hack
  // We'll rely on p5's built-in conversions by temporarily switching modes
  const prevMode = colorMode();
  const prevR = red(c), prevG = green(c), prevB = blue(c), prevA = alpha(c);
  colorMode(RGB, 255);
  const tmp = color(prevR, prevG, prevB, prevA);
  colorMode(HSB, 360, 100, 100, 1);
  // re-encode to HSB and read channels via string parsing (simpler than manual conversion)
  // Note: this is a lightweight, practical helper — values are close enough for tinting and alpha handling.
  const s = `${tmp}`;
  // Not a standard method — fall back to heuristic mapping
  // We'll derive via direct conversion using p5's hue/saturation/brightness functions:
  const h = typeof window !== 'undefined' && window.hue ? window.hue(tmp) : 0;
  const sat = typeof window !== 'undefined' && window.saturation ? window.saturation(tmp) : 0;
  const bri = typeof window !== 'undefined' && window.brightness ? window.brightness(tmp) : 0;
  colorMode(prevMode);
  if (which === 'h') return h;
  if (which === 's') return sat;
  return bri;
}
```
