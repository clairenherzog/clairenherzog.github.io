function setup() {
  createCanvas(400, 400);
}

function draw() {
  background(220);
}// A "voidlike" differential growth simulation that consumes other particles.
// by @rethread_art

// --- Main Void Form Settings ---
let voidParticles = [];
const numVoidParticles = 700; // More particles for intricate detail
const initialRadius = 150;

// --- Dust Particle Settings ---
let dustParticles = [];
const dustSpawnRate = 0.2; // How many new dust particles appear per frame
const maxDustParticles = 500;

// --- Physics & Forces ---
const gravity = 30;          // Strength of the void's pull on dust
const consumptionRadius = 15;   // How close dust must be to the void to be consumed
const repelStrength = 0.7;     // Internal repulsion of the void form
const attractStrength = 0.01;   // Internal cohesion of the void form
const alignStrength = 0.07;     // How much void particles flow together
const perturbationStrength = 2; // Random internal jolts to keep it chaotic
const damping = 0.97;           // Friction for all particles

// --- A generic class for a physics-based particle ---
class Particle {
  constructor(x, y) {
    this.pos = createVector(x, y);
    this.vel = createVector(random(-1, 1), random(-1, 1));
    this.acc = createVector(0, 0);
    this.lifespan = 255; // For fading effects
  }

  applyForce(force) {
    this.acc.add(force);
  }

  update() {
    this.vel.add(this.acc);
    this.vel.mult(damping);
    this.pos.add(this.vel);
    this.acc.mult(0);
  }
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  pixelDensity(1); // Use 1 for performance on high-density screens
  resetSketch();
}

function resetSketch() {
  voidParticles = [];
  dustParticles = [];
  
  // Initialize the central void form as a circle
  let angleStep = TWO_PI / numVoidParticles;
  for (let i = 0; i < numVoidParticles; i++) {
    let angle = i * angleStep;
    let x = width / 2 + cos(angle) * initialRadius;
    let y = height / 2 + sin(angle) * initialRadius;
    voidParticles.push(new Particle(x, y));
  }
}

function draw() {
  background(10, 10, 20, 50); // Deep space with a slight trail

  // --- 1. Spawn new dust particles at the edges ---
  if (random(1) < dustSpawnRate && dustParticles.length < maxDustParticles) {
    let x, y;
    if (random(1) > 0.5) {
      x = random() > 0.5 ? 0 : width;
      y = random(height);
    } else {
      x = random(width);
      y = random() > 0.5 ? 0 : height;
    }
    dustParticles.push(new Particle(x, y));
  }

  // --- 2. Calculate forces for the central void ---
  let centerOfMass = createVector(0, 0);
  for (let p of voidParticles) {
    centerOfMass.add(p.pos);
  }
  centerOfMass.div(voidParticles.length);

  for (let i = 0; i < voidParticles.length; i++) {
    let p = voidParticles[i];
    
    // Random perturbations to make it look unstable
    p.applyForce(p5.Vector.random2D().mult(perturbationStrength));
    
    // Standard differential growth forces (attract, repel, align)
    // (This logic is similar to the previous sketch)
    let forceRepel = createVector(0, 0);
    let forceAttract = createVector(0, 0);
    let forceAlign = createVector(0, 0);
    let alignNeighborCount = 0;

    let prev = voidParticles[(i - 1 + numVoidParticles) % numVoidParticles];
    let next = voidParticles[(i + 1) % numVoidParticles];
    
    let toPrev = p5.Vector.sub(prev.pos, p.pos);
    toPrev.mult(toPrev.mag() - 5);
    forceAttract.add(toPrev);

    let toNext = p5.Vector.sub(next.pos, p.pos);
    toNext.mult(toNext.mag() - 5);
    forceAttract.add(toNext);

    for (let j = 0; j < voidParticles.length; j++) {
      if (i === j) continue;
      let other = voidParticles[j];
      let d = p.pos.dist(other.pos);
      if (d > 0 && d < 15) {
        let repel = p5.Vector.sub(p.pos, other.pos);
        repel.normalize();
        repel.div(d);
        forceRepel.add(repel);
      }
      if (d > 0 && d < 50) {
        forceAlign.add(other.vel);
        alignNeighborCount++;
      }
    }
    
    if (alignNeighborCount > 0) {
      forceAlign.div(alignNeighborCount);
      forceAlign.sub(p.vel);
    }
    
    p.applyForce(forceAttract.mult(attractStrength));
    p.applyForce(forceRepel.mult(repelStrength));
    p.applyForce(forceAlign.mult(alignStrength));
  }

  // --- 3. Update and draw the void form ---
  noFill();
  beginShape();
  for (let i = 0; i < voidParticles.length; i++) {
    voidParticles[i].update();
    
    // Draw with dynamic stroke weight based on curvature
    let p = voidParticles[i];
    let prev = voidParticles[(i - 1 + numVoidParticles) % numVoidParticles];
    let next = voidParticles[(i + 1) % numVoidParticles];
    let angle = p5.Vector.sub(p.pos, prev.pos).angleBetween(p5.Vector.sub(next.pos, p.pos));
    let sw = map(abs(angle), 0, PI, 5, 0.5);
    strokeWeight(sw);
    stroke(0, 150, 200, 150); // A dark, cyan-tinted void
    if (i === 0) curveVertex(voidParticles[voidParticles.length-1].pos.x, voidParticles[voidParticles.length-1].pos.y);
    curveVertex(p.pos.x, p.pos.y);
    if (i === voidParticles.length - 1) {
       curveVertex(voidParticles[0].pos.x, voidParticles[0].pos.y);
       curveVertex(voidParticles[1].pos.x, voidParticles[1].pos.y);
    }
  }
  endShape();
  
  // --- 4. Update dust particles (gravity and consumption) ---
  for (let i = dustParticles.length - 1; i >= 0; i--) {
    let d = dustParticles[i];
    
    // Apply gravity towards the void's center of mass
    let toCenter = p5.Vector.sub(centerOfMass, d.pos);
    let distSq = toCenter.magSq();
    toCenter.normalize();
    toCenter.mult(gravity * 200 / (distSq + 100)); // Simulated gravity, stable at close range
    d.applyForce(toCenter);
    
    d.update();
    d.lifespan -= 0.5;

    // Draw dust particle
    stroke(255, 220, 200, d.lifespan); // Star-like color
    strokeWeight(random(1, 2.5));
    point(d.pos.x, d.pos.y);
    
    // Check for consumption
    let distToCenter = d.pos.dist(centerOfMass);
    if (distToCenter < consumptionRadius * 4) { // An outer check for performance
      for (let vp of voidParticles) {
        if (d.pos.dist(vp.pos) < consumptionRadius) {
          d.lifespan = 0; // Mark for removal if consumed
          break;
        }
      }
    }
    
    // Remove if faded or consumed
    if (d.lifespan < 0) {
      dustParticles.splice(i, 1);
    }
  }
}

function mousePressed() {
  resetSketch();
}
